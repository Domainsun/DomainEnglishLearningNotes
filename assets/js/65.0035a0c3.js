(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{375:function(e,t,r){"use strict";r.r(t);var i=r(14),a=Object(i.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"技术难点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#技术难点"}},[e._v("#")]),e._v(" 技术难点")]),e._v(" "),t("h3",{attrs:{id:"recyclerview-大量排序列表加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#recyclerview-大量排序列表加载"}},[e._v("#")]),e._v(" RecyclerView 大量排序列表加载")]),e._v(" "),t("p",[e._v("生辰库列表加载，优化内存。")]),e._v(" "),t("p",[e._v("加载一个需要排序的大数量的列表数据。")]),e._v(" "),t("p",[e._v("引出RecyclerView原理。技术点：懂RecyclerView原理。 懂享元模式，懂数据结构ArrayList，懂内存回收。")]),e._v(" "),t("p",[e._v("优化描述：")]),e._v(" "),t("p",[e._v("通过自定义LayoutManger,来自定义itemView的填充逻辑。 我们知道我们默认的给RecyerView一个数据列表ListView。 那RecyclerView就会显示我们给的这个数据的大小来展示多少条数据。 假设我们给10条，就展示10条。 给1万条就展示一万条。 但RecyclerView做了优化， 一次只会展示渲染屏幕可见的条目数，实现了ItemView的复用。 RecyclerView复用的ViewHolder,在这个对象里面， 有itemView,和position。  但没有复用data,所以我们给RecyclerView的一万条数据的这个列表中对象并不会被回收。一个空的Java对象的占用的内存是16个字节。 一万条数据占用的内存最少有一两百兆。所以用享用模式实现了一个data的复用池。 在滚动到适当的时候去更新这个复用池。 然后RecyclerView复用View走onCreateViewHolder或者onBindViewHolder的时候， 去这个复用池里面取数据。 这样所占用的内存大小就是初始展示时的一个list和复用池的list的大小。")]),e._v(" "),t("hr"),e._v(" "),t("h3",{attrs:{id:"公农历转化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#公农历转化"}},[e._v("#")]),e._v(" 公农历转化")]),e._v(" "),t("p",[e._v("引出享元模式，和其他设计模式。")])])}),[],!1,null,null,null);t.default=a.exports}}]);