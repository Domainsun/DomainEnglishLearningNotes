(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{371:function(a,t,n){"use strict";n.r(t);var o=n(14),e=Object(o.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"android-协调布局"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#android-协调布局"}},[a._v("#")]),a._v(" Android 协调布局")]),a._v(" "),t("p",[a._v("总结来说：\n协调布局CoordinatorLayout，协调AppBarLayout和一个滚动View,比如recyclerView、ScrollView， 让滚动的View在滚动的时候， AppBarLayout中中的子view做对应的响应， 对应下面五个属性。 滚动的View要加"),t("code",[a._v('app:layout_behavior="@string/appbar_scrolling_view_behavior"')]),a._v("属性， 如果出现滑动时闪烁等问题可以用"),t("code",[a._v("https://github.com/yuruiyin/AppbarLayoutBehavior")]),a._v("自定义的behavior解决。")]),a._v(" "),t("p",[a._v("CollapsingToolbarLayout做AppBarLayout的子view还可以实现视差滚动效果。")]),a._v(" "),t("p",[a._v("CoordinatorLayout + AppBarLayout + RecyclerView")]),a._v(" "),t("p",[a._v("CoordinatorLayout 是协调布局， 用来协调RecyclerView滚动时，AppBarLayout中子view如何滚动。\nAppBarLayout的子view通过"),t("code",[a._v("layout_scrollFlags")]),a._v("属性来标识要怎么响应滚动。")]),a._v(" "),t("p",[a._v("layout_scrollFlags的属性")]),a._v(" "),t("ul",[t("li",[a._v("scroll ：加上这个才能参与滚动，使用其他属性也必须要加上这个属性")]),a._v(" "),t("li",[a._v("enterAlways：先滚动toolbar")]),a._v(" "),t("li",[a._v("enterAlwaysCollapsed：要和scroll、enterAlways和最小高度一起使用，"),t("code",[a._v('app:layout_scrollFlags="scroll|enterAlways|enterAlwaysCollapsed" android:minHeight="50dp"')]),a._v("，展开时先展开到最小高度， 最后才展开全部。")]),a._v(" "),t("li",[a._v("exitUntilCollapsed：要和scroll和最小高度一起使用，"),t("code",[a._v('app:layout_scrollFlags="scroll|exitUntilCollapsed" android:minHeight="50dp"')]),a._v("，收缩时，收缩到最小高度。")]),a._v(" "),t("li",[a._v("snap： 要和scroll配合使用，"),t("code",[a._v('app:layout_scrollFlags="scroll|snap"')]),a._v(", 展开或者收缩到一半， 会自动展开或收缩完。")]),a._v(" "),t("li",[a._v("snapMargins：必须和snap配合使用, 以margin的距离snap。")])]),a._v(" "),t("p",[a._v("CollapsingToolbarLayout 折叠布局作为AppBarLayout的子布局，CollapsingToolbarLayout的子view可以设置三个属性来响应滚动。")]),a._v(" "),t("ul",[t("li",[a._v("off：不折叠")]),a._v(" "),t("li",[a._v("parallax：视差效果折叠")]),a._v(" "),t("li",[a._v("pin：折叠后固定\n"),t("code",[a._v('app:layout_collapseMode="parallax"')])])]),a._v(" "),t("h2",{attrs:{id:"appbarlayout-折叠展开监听"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#appbarlayout-折叠展开监听"}},[a._v("#")]),a._v(" AppBarLayout 折叠展开监听")]),a._v(" "),t("p",[a._v("binding.llHeader 是CollapsingToolbarLayout中pin属性的子view。 默认隐藏， 因为pin是固定显示的。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('\n    private CollapsingToolbarLayoutState state;\n    private enum CollapsingToolbarLayoutState {\n        EXPANDED,\n        COLLAPSED,\n        INTERNEDIATE\n    }\n    \n    \n        binding.appBar.addOnOffsetChangedListener(new AppBarLayout.OnOffsetChangedListener() {\n            @Override\n            public void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) {\n                if (verticalOffset == 0) {\n                    if (state != CollapsingToolbarLayoutState.EXPANDED) {\n                        state = CollapsingToolbarLayoutState.EXPANDED;//修改状态标记为展开\n//                        binding.tvHeader.setText("EXPANDED");//设置title为EXPANDED\n                    }\n                } else if (Math.abs(verticalOffset) >= appBarLayout.getTotalScrollRange()) {\n                    if (state != CollapsingToolbarLayoutState.COLLAPSED) {\n//                        binding.tvHeader.setText("");//设置title不显示\n                        binding.llHeader.setVisibility(View.VISIBLE);//隐藏播放按钮\n                        state = CollapsingToolbarLayoutState.COLLAPSED;//修改状态标记为折叠\n                    }\n                } else {\n                    if (state != CollapsingToolbarLayoutState.INTERNEDIATE) {\n                        if(state == CollapsingToolbarLayoutState.COLLAPSED){\n                            binding.llHeader.setVisibility(View.INVISIBLE);//由折叠变为中间状态时隐藏播放按钮\n                        }\n//                        binding.tvHeader.setText("INTERNEDIATE");//设置title为INTERNEDIATE\n                        state = CollapsingToolbarLayoutState.INTERNEDIATE;//修改状态标记为中间\n                    }\n                }\n            }\n        });\n\n    \n')])])]),t("h2",{attrs:{id:"应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[a._v("#")]),a._v(" 应用场景")]),a._v(" "),t("p",[a._v("AppBarLayout 可以实现中的子view可以实现，"),t("strong",[a._v("完全视差收缩， 或视差收缩到指定的minHeight。")]),a._v(" tablayout放在")]),a._v(" "),t("p",[t("strong",[a._v("去除AppBarLayout自带底部阴影")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('app:elevation="@dimen/dp0"\n')])])]),t("p",[t("strong",[a._v("xml布局示例")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('<?xml version="1.0" encoding="utf-8"?>\n<layout xmlns:android="http://schemas.android.com/apk/res/android"\n    xmlns:app="http://schemas.android.com/apk/res-auto">\n\n    <data>\n\n    </data>\n\n    <RelativeLayout\n        android:layout_width="match_parent"\n        android:layout_height="match_parent">\n\n\n        <androidx.coordinatorlayout.widget.CoordinatorLayout\n            android:layout_width="match_parent"\n            android:layout_height="match_parent">\n\n            <com.google.android.material.appbar.AppBarLayout\n                android:layout_width="match_parent"\n                android:layout_height="wrap_content"\n                app:elevation="0dp">\n\n                <TextView\n                    android:layout_width="match_parent"\n                    android:layout_height="400dp"\n                    android:background="#222222"\n                    android:gravity="center"\n                    android:minHeight="50dp"\n                    android:text="该区域可折叠"\n                    android:textColor="@android:color/white"\n                    android:textSize="30sp"\n                    app:layout_scrollFlags="scroll|exitUntilCollapsed" />\n                \x3c!--                app:layout_scrollFlags="scroll"--\x3e\n\n                <TextView\n                    android:layout_width="match_parent"\n                    android:layout_height="50dp"\n                    android:background="#DD012D"\n                    android:gravity="center"\n                    android:text="该区域为上滑至头部固定区域"\n                    android:textColor="@android:color/white"\n                    android:textSize="20sp" />\n            </com.google.android.material.appbar.AppBarLayout>\n\n            <androidx.core.widget.NestedScrollView\n                android:id="@+id/rv_demo1_content"\n                android:layout_width="match_parent"\n                android:layout_height="wrap_content"\n                app:layout_behavior="@string/appbar_scrolling_view_behavior">\n\n                <TextView\n                    android:layout_width="match_parent"\n                    android:layout_height="wrap_content"\n                    android:background="#00ff00"\n                    android:text="这是一个滚动布局"\n                    android:textSize="200sp" />\n            </androidx.core.widget.NestedScrollView>\n        </androidx.coordinatorlayout.widget.CoordinatorLayout>\n\n        <TextView\n            android:layout_width="match_parent"\n            android:layout_height="50dp"\n            android:background="@color/blue"\n            android:gravity="center"\n            android:text="标题"\n            android:textSize="24sp"></TextView>\n    </RelativeLayout>\n\n</layout>\n\n')])])])])}),[],!1,null,null,null);t.default=e.exports}}]);