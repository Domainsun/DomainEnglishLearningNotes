(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{382:function(a,e,n){"use strict";n.r(e);var t=n(14),v=Object(t.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"设计模式和设计原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计模式和设计原则"}},[a._v("#")]),a._v(" 设计模式和设计原则")]),a._v(" "),e("h3",{attrs:{id:"资料参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#资料参考"}},[a._v("#")]),a._v(" 资料参考")]),a._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://blog.csdn.net/weixin_46034226/article/details/103744273",target:"_blank",rel:"noopener noreferrer"}},[a._v("总结"),e("OutboundLink")],1)]),a._v(" "),e("li",[e("a",{attrs:{href:"https://segmentfault.com/a/1190000040294370",target:"_blank",rel:"noopener noreferrer"}},[a._v("代码实现"),e("OutboundLink")],1)]),a._v(" "),e("li",[e("a",{attrs:{href:"https://www.jianshu.com/p/1a9f571ad7c0",target:"_blank",rel:"noopener noreferrer"}},[a._v("简书"),e("OutboundLink")],1)])]),a._v(" "),e("h3",{attrs:{id:"_6-7大设计原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-7大设计原则"}},[a._v("#")]),a._v(" 6/7大设计原则")]),a._v(" "),e("p",[e("s",[a._v("记忆口诀：开口合里最单依")])]),a._v(" "),e("ul",[e("li",[a._v("开闭原则")]),a._v(" "),e("li",[a._v("接口隔离原则")]),a._v(" "),e("li",[a._v("聚合原则")]),a._v(" "),e("li",[a._v("里式替换原则")]),a._v(" "),e("li",[a._v("最少知识原则")]),a._v(" "),e("li",[a._v("单一职责原则")]),a._v(" "),e("li",[a._v("依赖倒置原则")])]),a._v(" "),e("p",[e("strong",[a._v("最少知识原则：")]),a._v("\n一个类，应该对其他类的信息应该知道尽量少。对依赖者来说只依赖应该依赖的类， 对提供者来说只暴露应该暴露的方法。 就是说，我调用一个方法，不管这个方法内部多么复杂， 对于调用者来只需要调用这个方法就能完全对应的行为逻辑。")]),a._v(" "),e("p",[e("strong",[a._v("单一职责原则：")]),a._v("\n一个类负责一个一项职责，也就是属于同一项职责的代码需放在同一个类中实现。")]),a._v(" "),e("p",[a._v("使用外观模式，单例模式实现，缺点：不符合开闭原则。")]),a._v(" "),e("p",[e("strong",[a._v("开闭原则：")])]),a._v(" "),e("p",[a._v("对修改关闭，对扩展开放。 开发新功能，不应该修改原有代码，而是通过拓展的方式。大理模式符合这个原则。")]),a._v(" "),e("p",[e("strong",[a._v("依赖倒置原则：")])]),a._v(" "),e("p",[a._v("高层模块不应该依赖底层模块，两者应该依赖其抽象。 这就是就是面向接口编程的思想。")]),a._v(" "),e("p",[a._v("代理模式符合这个原则。")]),a._v(" "),e("p",[e("strong",[a._v("接口隔离原则：")]),a._v("\n建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用")]),a._v(" "),e("p",[e("strong",[a._v("里式替换原则")])]),a._v(" "),e("p",[a._v("**定义：**所有父类的对象， 都可以替换为子类对象，并且不会破坏程序，改变程序行为。\n**解释：**子类继承父类， 应该是扩展父类，而不是重写父类的行为。如果为了实现多态重写父类方法， 那父类应该为抽象类。 父类为抽象类时，不能够直接实例化父类。 所以和这个原则定义也不冲突。\n**总结：**总结来说就是， 如果父类不是抽象类，不应该复写父类的方法。")]),a._v(" "),e("p",[e("strong",[a._v("聚合原则：")])]),a._v(" "),e("p",[a._v("能组合，不继承。")]),a._v(" "),e("p",[a._v("代理模式实现这个这个原则。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('步骤 1\n创建一个接口。\n\nImage.java\npublic interface Image {\n   void display();\n}\n\n步骤 2\n创建实现接口的实体类。\n\nRealImage.java\npublic class RealImage implements Image {\n \n   private String fileName;\n \n   public RealImage(String fileName){\n      this.fileName = fileName;\n      loadFromDisk(fileName);\n   }\n \n   @Override\n   public void display() {\n      System.out.println("Displaying " + fileName);\n   }\n \n   private void loadFromDisk(String fileName){\n      System.out.println("Loading " + fileName);\n   }\n}\n\n\n\nProxyImage.java\npublic class ProxyImage implements Image{\n \n   private RealImage realImage;\n   private String fileName;\n \n   public ProxyImage(String fileName){\n      this.fileName = fileName;\n   }\n \n   @Override\n   public void display() {\n      if(realImage == null){\n         realImage = new RealImage(fileName);\n      }\n      realImage.display();\n   }\n}\n\n\n步骤 3\n当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。\n\nProxyPatternDemo.java\npublic class ProxyPatternDemo {\n   \n   public static void main(String[] args) {\n      Image image = new ProxyImage("test_10mb.jpg");\n \n      // 图像将从磁盘加载\n      image.display(); \n      System.out.println("");\n      // 图像不需要从磁盘加载\n      image.display();  \n   }\n}\n')])])]),e("p",[a._v("比如封装支付Sdk，应该抽象出一个接口出来，不同的支付方式去实现这个接口。")]),a._v(" "),e("p",[a._v("在使用支付Sdk时， 只需要实例化对应的支付方式即可。 新增支付方式只需要")]),a._v(" "),e("p",[a._v("高层（比如）")]),a._v(" "),e("p",[a._v("这就是平常说的面向接口编程。")]),a._v(" "),e("p",[a._v("策略模式")]),a._v(" "),e("p",[a._v("去除if else")]),a._v(" "),e("h3",{attrs:{id:"_23种设计模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_23种设计模式"}},[a._v("#")]),a._v(" 23种设计模式")]),a._v(" "),e("h4",{attrs:{id:"设计模式的分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的分类"}},[a._v("#")]),a._v(" 设计模式的分类")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("创建型")]),a._v(" "),e("p",[a._v("负责对象的创建")])]),a._v(" "),e("li",[e("p",[a._v("结构型")]),a._v(" "),e("p",[a._v("负责通过组合多个不同的对象来提供统一的方法")])]),a._v(" "),e("li",[e("p",[a._v("行为型")]),a._v(" "),e("p",[a._v("负责对象之间的通信")])])]),a._v(" "),e("h4",{attrs:{id:"常用的一些设计模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常用的一些设计模式"}},[a._v("#")]),a._v(" 常用的一些设计模式")]),a._v(" "),e("h5",{attrs:{id:"创建型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建型"}},[a._v("#")]),a._v(" 创建型")]),a._v(" "),e("ul",[e("li",[a._v("单例")]),a._v(" "),e("li",[a._v("工厂方法")]),a._v(" "),e("li",[a._v("抽象工厂")]),a._v(" "),e("li",[a._v("建造者")])]),a._v(" "),e("h5",{attrs:{id:"结构性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结构性"}},[a._v("#")]),a._v(" 结构性")]),a._v(" "),e("ul",[e("li",[a._v("适配器")]),a._v(" "),e("li",[a._v("代理")]),a._v(" "),e("li",[a._v("门面（外观）")]),a._v(" "),e("li",[a._v("享元")]),a._v(" "),e("li",[a._v("装饰")])]),a._v(" "),e("h5",{attrs:{id:"行为型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#行为型"}},[a._v("#")]),a._v(" 行为型")]),a._v(" "),e("ul",[e("li",[a._v("观察者")]),a._v(" "),e("li",[a._v("策略")]),a._v(" "),e("li",[a._v("模板方法")]),a._v(" "),e("li",[a._v("责任链")])]),a._v(" "),e("h3",{attrs:{id:"实例应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实例应用"}},[a._v("#")]),a._v(" 实例应用")]),a._v(" "),e("p",[a._v("门面-单例-")]),a._v(" "),e("h2",{attrs:{id:"单例模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[a._v("#")]),a._v(" 单例模式")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("private volatile static DBHelper instance;  //1:volatile修饰\n\nprivate DBHelper() {\n    init();\n}\n\npublic static DBHelper getInstance() {\n    if (instance == null) {  //2:减少不要同步，优化性能\n        synchronized (DBHelper.class) {  // 3：同步，线程安全\n            if (instance == null) {\n                instance = new DBHelper();  //4： 对象\n            }\n        }\n    }\n    return instance;\n}\n\nprivate void init(){\n\n};\n")])])])])}),[],!1,null,null,null);e.default=v.exports}}]);